/**
 * GeneratedProjectWriter
 * 
 * Writes generated source code to disk in a properly structured format
 * that can be run locally (npm install, npm test, npm start)
 * 
 * Creates:
 * - package.json with all dependencies and scripts
 * - Source files (src/)
 * - Test files (test/)
 * - Configuration files (.env, .gitignore, etc.)
 */

import fs from 'node:fs';
import path from 'node:path';

export default class GeneratedProjectWriter {
  constructor(options = {}) {
    this.projectRoot = options.projectRoot;
    this.projectName = options.projectName;
    this.logger = options.logger;

    if (!this.projectRoot) {
      throw new Error('GeneratedProjectWriter requires projectRoot');
    }
  }

  /**
   * Write generated code to disk
   */
  writeProject(generatedOutput) {
    const startTime = Date.now();
    const results = {
      files: [],
      errors: [],
    };

    try {
      // Create directory structure
      this._ensureDirectories();

      // Write package.json
      this.writePackageJson(generatedOutput.projectMetadata);
      results.files.push('package.json');

      // Write source files
      if (generatedOutput.sourceCode) {
        const srcFiles = this.writeSourceCode(generatedOutput.sourceCode);
        results.files.push(...srcFiles);
      }

      // Write test files
      if (generatedOutput.testCode) {
        const testFiles = this.writeTestCode(generatedOutput.testCode);
        results.files.push(...testFiles);
      }

      // Write configuration files
      if (generatedOutput.config) {
        const configFiles = this.writeConfig(generatedOutput.config);
        results.files.push(...configFiles);
      }

      // Write documentation
      if (generatedOutput.documentation) {
        const docFiles = this.writeDocumentation(generatedOutput.documentation);
        results.files.push(...docFiles);
      }

      // Write .gitignore
      this.writeGitignore();
      results.files.push('.gitignore');

      const duration = Date.now() - startTime;
      if (this.logger) {
        this.logger.debug('Project written to disk', {
          projectRoot: this.projectRoot,
          filesWritten: results.files.length,
          duration: `${(duration / 1000).toFixed(2)}s`,
        });
      }

      return {
        success: true,
        projectRoot: this.projectRoot,
        filesWritten: results.files,
        count: results.files.length,
      };
    } catch (error) {
      results.errors.push(error.message);
      if (this.logger) {
        this.logger.error('Failed to write project', {
          error: error.message,
          projectRoot: this.projectRoot,
        });
      }
      throw error;
    }
  }

  /**
   * Create directory structure
   */
  _ensureDirectories() {
    const dirs = [
      path.join(this.projectRoot, 'generated-code/src'),
      path.join(this.projectRoot, 'generated-code/test'),
      path.join(this.projectRoot, 'generated-code/docs'),
    ];

    for (const dir of dirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    }
  }

  /**
   * Write package.json with all dependencies and scripts
   */
  writePackageJson(metadata = {}) {
    const packageJson = {
      name: this.projectName,
      version: '1.0.0',
      description: metadata.description || `Generated by Forge AI: ${this.projectName}`,
      type: 'module',
      main: metadata.main || 'src/index.js',
      scripts: {
        start: metadata.scripts?.start || 'node src/index.js',
        test: metadata.scripts?.test || 'node --test test/**/*.test.js',
        dev: 'node --watch src/index.js',
        lint: 'eslint src/ test/',
      },
      keywords: ['forge-ai', 'generated', this.projectName],
      author: 'Forge AI',
      license: 'MIT',
      dependencies: metadata.dependencies || {},
      devDependencies: metadata.devDependencies || {
        eslint: '^8.50.0',
      },
    };

    const filePath = path.join(this.projectRoot, 'generated-code/package.json');
    fs.writeFileSync(filePath, JSON.stringify(packageJson, null, 2));
    return filePath;
  }

  /**
   * Write source code files
   */
  writeSourceCode(sourceCode) {
    const files = [];

    if (typeof sourceCode === 'object') {
      for (const [filename, content] of Object.entries(sourceCode)) {
        const filePath = path.join(this.projectRoot, 'generated-code/src', filename);
        
        // Create parent directories if needed
        const dir = path.dirname(filePath);
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(filePath, content);
        files.push(`src/${filename}`);
      }
    } else if (typeof sourceCode === 'string') {
      // Single file: index.js
      const filePath = path.join(this.projectRoot, 'generated-code/src/index.js');
      fs.writeFileSync(filePath, sourceCode);
      files.push('src/index.js');
    }

    return files;
  }

  /**
   * Write test files
   */
  writeTestCode(testCode) {
    const files = [];

    if (typeof testCode === 'object') {
      for (const [filename, content] of Object.entries(testCode)) {
        const filePath = path.join(this.projectRoot, 'generated-code/test', filename);
        
        // Create parent directories if needed
        const dir = path.dirname(filePath);
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(filePath, content);
        files.push(`test/${filename}`);
      }
    } else if (typeof testCode === 'string') {
      // Single file: index.test.js
      const filePath = path.join(this.projectRoot, 'generated-code/test/index.test.js');
      fs.writeFileSync(filePath, testCode);
      files.push('test/index.test.js');
    }

    return files;
  }

  /**
   * Write configuration files
   */
  writeConfig(config) {
    const files = [];

    // Write .env.template
    if (config.env) {
      const envPath = path.join(this.projectRoot, 'generated-code/.env.template');
      const envContent = typeof config.env === 'object'
        ? Object.entries(config.env)
            .map(([key, value]) => `${key}=${value}`)
            .join('\n')
        : config.env;
      fs.writeFileSync(envPath, envContent);
      files.push('.env.template');
    }

    // Write other config files
    if (config.eslintrc) {
      const eslintPath = path.join(this.projectRoot, 'generated-code/.eslintrc.json');
      fs.writeFileSync(eslintPath, JSON.stringify(config.eslintrc, null, 2));
      files.push('.eslintrc.json');
    }

    if (config.prettierrc) {
      const prettierPath = path.join(this.projectRoot, 'generated-code/.prettierrc');
      fs.writeFileSync(prettierPath, JSON.stringify(config.prettierrc, null, 2));
      files.push('.prettierrc');
    }

    return files;
  }

  /**
   * Write documentation files
   */
  writeDocumentation(documentation) {
    const files = [];

    if (typeof documentation === 'object') {
      for (const [filename, content] of Object.entries(documentation)) {
        const filePath = path.join(this.projectRoot, 'generated-code/docs', filename);
        
        // Create parent directories if needed
        const dir = path.dirname(filePath);
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(filePath, content);
        files.push(`docs/${filename}`);
      }
    }

    return files;
  }

  /**
   * Write .gitignore
   */
  writeGitignore() {
    const gitignorePath = path.join(this.projectRoot, 'generated-code/.gitignore');
    const content = `# Dependencies
node_modules/
package-lock.json
npm-debug.log

# Environment
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log
`;
    fs.writeFileSync(gitignorePath, content);
    return gitignorePath;
  }

  /**
   * Get project ready for local development
   */
  getLocalDevInstructions() {
    const projectPath = path.join(this.projectRoot, 'generated-code');
    return {
      setup: [
        `cd ${projectPath}`,
        'npm install',
      ],
      run: {
        development: 'npm run dev',
        production: 'npm start',
        test: 'npm test',
      },
      instructions: `
# Local Development Setup

## 1. Install Dependencies
cd ${projectPath}
npm install

## 2. Run Tests
npm test

## 3. Start Development
npm run dev   # Watch mode with auto-reload
npm start     # Single run

## 4. Next Steps
- Edit source code in src/
- Tests are in test/
- Run tests with: npm test
- Build ready when npm test passes 100%
- Then run Docker deployment with Phase 10
`,
    };
  }
}
