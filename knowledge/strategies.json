{
  "version": "2.0",
  "last_updated": "2025-12-07T16:05:00Z",
  "metadata": {
    "description": "Forge AI Strategies - Systematic approaches with quality metrics",
    "focus": "Token efficiency, workflow completeness, code quality"
  },
  "quality_threshold": {
    "minimum_token_efficiency": 0.75,
    "minimum_workflow_impact": 0.80,
    "minimum_success_rate": 0.85
  },
  "strategies": [
    {
      "id": "strat-001-entry-point-propagation",
      "name": "Entry Point Propagation Strategy",
      "description": "Systematic approach for defining and propagating entry points through all workflow phases",
      "phases": {
        "phase_2_functional": {
          "name": "Functional Requirements Definition",
          "steps": [
            "Identify application type (CLI, API, Full-Stack, etc.)",
            "Define entry point location as explicit requirement",
            "Document expected entry point: src/index.js, src/cli.js, src/server.js, etc.",
            "Include in acceptance criteria: 'Application starts from [entry_point]'"
          ]
        },
        "phase_3_technical": {
          "name": "Technical Specification",
          "steps": [
            "Extract entry point from functional requirements",
            "Create primary API with path field matching entry point",
            "Example: apis[0] = { name: 'main', path: 'src/index.js', type: 'CLI' }",
            "Document non-functional requirements for runtime (Node.js version, ports, etc.)"
          ]
        },
        "phase_6_implementation": {
          "name": "Code Implementation",
          "steps": [
            "Generate code for entry point as specified in Phase 3",
            "Verify generated code matches apis[0].path",
            "In output, propagate technicalRequirements from Phase 3",
            "Ensure package.json main field matches entry point",
            "All generated test files should import from correct entry point"
          ]
        },
        "phase_10_deployment": {
          "name": "Deployment & Containerization",
          "steps": [
            "Read technicalRequirements from Phase 6 output",
            "Extract entry point from apis[0].path (PRIMARY SOURCE)",
            "Generate Dockerfile with ENTRYPOINT ['node', apis[0].path]",
            "Generate docker-compose.yml with matching command",
            "Verify entry point in all deployment artifacts",
            "Run tests in container to verify correct startup"
          ]
        }
      },
      "detection_algorithm": {
        "priority_order": [
          {
            "rank": 1,
            "source": "technicalRequirements.apis[0].path",
            "reliability": "high",
            "reason": "Explicitly specified in Phase 3"
          },
          {
            "rank": 2,
            "source": "projectMetadata.main",
            "reliability": "medium",
            "reason": "From package.json"
          },
          {
            "rank": 3,
            "source": "generated_files pattern matching",
            "reliability": "low",
            "reason": "Heuristic based on file names"
          }
        ]
      },
      "quality_checks": [
        "Entry point exists in generated code",
        "Entry point is executable (has proper exports/ENTRYPOINT)",
        "Package.json main field matches entry point",
        "Dockerfile ENTRYPOINT matches entry point",
        "All tests pass starting from entry point",
        "Container starts without errors"
      ],
      "anti_patterns": [
        "Hardcoding entry points in deployment phase",
        "Guessing entry point from file system",
        "Using different entry points in tests vs deployment",
        "Not propagating entry point info between phases"
      ],
      "success_rate": 0.95,
      "recommended_for": [
        "CLI applications",
        "API servers",
        "Full-stack applications",
        "Any code generation + containerization workflow"
      ],
      "tags": ["entry-point", "deployment", "docker", "workflow", "architecture"],
      "quality_metrics": {
        "workflow_completeness": 100,
        "code_efficiency": 80,
        "feature_completeness": 90,
        "test_quality": 85,
        "resource_efficiency": 95,
        "overall_score": 90,
        "token_cost": "low",
        "complexity": "medium",
        "priority": "CRITICAL"
      }
    },
    {
      "id": "strat-002-dockerfile-generation",
      "name": "Dockerfile Generation Strategy for Auto-Generated Code",
      "description": "Systematic approach for generating production-ready Dockerfiles from specifications",
      "architecture": {
        "single_stage": {
          "when_to_use": "Always prefer for generated code",
          "structure": [
            "FROM node:X-alpine",
            "WORKDIR /app",
            "COPY package*.json ./",
            "RUN npm ci (dependencies)",
            "COPY generated-code/src ./src",
            "COPY generated-code/docs ./docs",
            "COPY generated-code/test ./test (optional)",
            "RUN npm test (validate in build)",
            "ENV NODE_ENV=production",
            "LABEL ... (metadata)",
            "ENTRYPOINT ['node', '{entry_point}']"
          ],
          "benefits": [
            "Reduced complexity for agents",
            "Smaller final images",
            "Tests validate containerization",
            "Deterministic builds"
          ]
        }
      },
      "critical_decisions": {
        "base_image": {
          "choice": "node:X-alpine",
          "reasoning": [
            "5MB base vs 150MB slim",
            "Sufficient for Node.js apps",
            "Smaller attack surface",
            "Consistent across projects"
          ],
          "fallback": "node:X-bullseye if native modules needed"
        },
        "dependency_installation": {
          "choice": "npm ci --only=production",
          "reasoning": [
            "Deterministic installs",
            "Reproducible builds",
            "Smaller production images"
          ],
          "caveat": "Use full 'npm ci' if running tests in Docker"
        },
        "test_execution": {
          "when": "During Docker build (RUN npm test)",
          "benefit": "Fail fast, ensure containerization works",
          "timing": "Before ENV NODE_ENV=production"
        },
        "entry_point": {
          "source": "technicalRequirements.apis[0].path",
          "validation": "Must exist in generated code",
          "format": "ENTRYPOINT ['node', '{path}']"
        }
      },
      "key_points": [
        "All paths must be relative to WORKDIR /app",
        "Tests run during build (quality gate)",
        "Environment set to production",
        "Metadata labels included",
        "Non-root user recommended"
      ],
      "common_mistakes": [
        {
          "mistake": "Hardcoding paths like '/app/src/index.js'",
          "fix": "Use relative paths after COPY"
        },
        {
          "mistake": "Copying node_modules from source",
          "fix": "Always npm ci in container"
        },
        {
          "mistake": "Using 'latest' image tag",
          "fix": "Explicit version: node:22-alpine"
        },
        {
          "mistake": "Not cleaning package*.json copy",
          "fix": "COPY package*.json to catch lock files"
        }
      ],
      "templates_for_different_types": {
        "cli_application": {
          "entry_point_type": "src/index.js or src/cli.js",
          "no_ports": true,
          "healthcheck": false,
          "cmd": "[]"
        },
        "api_server": {
          "entry_point_type": "src/server.js or src/app.js",
          "ports": "3000 (default)",
          "healthcheck": true,
          "health_endpoint": "/health"
        },
        "background_worker": {
          "entry_point_type": "src/worker.js",
          "no_ports": true,
          "healthcheck": false,
          "restart_policy": "on-failure"
        }
      },
      "success_rate": 0.92,
      "tags": ["dockerfile", "docker", "containerization", "generated-code"],
      "quality_metrics": {
        "workflow_completeness": 100,
        "code_efficiency": 95,
        "feature_completeness": 70,
        "test_quality": 100,
        "resource_efficiency": 90,
        "overall_score": 91,
        "token_cost": "low",
        "complexity": "low",
        "priority": "CRITICAL",
        "note": "Single-stage approach minimizes tokens AND complexity"
      }
    },
    {
      "id": "strat-003-deployment-coordination",
      "name": "Deployment Artifact Coordination Strategy",
      "description": "How to generate and write Dockerfile, docker-compose.yml, and supporting files",
      "artifacts": {
        "dockerfile": {
          "location": "deployment/Dockerfile",
          "responsibility": "Core container configuration",
          "generation": "From technical specs (Phase 3)"
        },
        "docker_compose": {
          "location": "deployment/docker-compose.yml",
          "responsibility": "Local orchestration",
          "generation": "From entry point + project metadata"
        },
        "dockerignore": {
          "location": "deployment/.dockerignore",
          "responsibility": "Build optimization",
          "contents": [
            "node_modules",
            "test/",
            "deployment/",
            "reports/",
            ".git",
            "README.md",
            "*.md (documentation)"
          ]
        },
        "env_template": {
          "location": "deployment/.env.template",
          "responsibility": "Environment configuration reference",
          "generation": "From technicalRequirements.nonFunctionalRequirements"
        },
        "deployment_guide": {
          "location": "deployment/DEPLOYMENT.md",
          "responsibility": "Human-readable guide",
          "contents": [
            "Quick start (docker build, docker run)",
            "Image details",
            "Environment variables",
            "Troubleshooting"
          ]
        },
        "deployment_checklist": {
          "location": "deployment/CHECKLIST.md",
          "responsibility": "Pre-deployment validation",
          "sections": [
            "Pre-Deployment",
            "Security Checks",
            "Performance Validation",
            "Documentation",
            "Testing",
            "Post-Deployment"
          ]
        }
      },
      "writing_order": [
        "1. Dockerfile (core, most critical)",
        "2. docker-compose.yml (orchestration)",
        "3. .dockerignore (optimization)",
        "4. .env.template (configuration)",
        "5. DEPLOYMENT.md (guide)",
        "6. CHECKLIST.md (validation)"
      ],
      "error_handling": {
        "directory_creation": "fs.mkdirSync(deploymentDir, { recursive: true })",
        "file_writing": "Use try-catch for each file, log errors",
        "return_value": "Array of written filenames for orchestrator tracking"
      },
      "validation": [
        "All files written successfully",
        "No empty files",
        "YAML syntax valid (docker-compose.yml)",
        "Dockerfile has FROM and ENTRYPOINT",
        "Paths are correct in Dockerfile"
      ],
      "success_rate": 0.98,
      "tags": ["deployment", "docker", "file-writing", "orchestration"],
      "quality_metrics": {
        "workflow_completeness": 100,
        "code_efficiency": 85,
        "feature_completeness": 50,
        "test_quality": 70,
        "resource_efficiency": 95,
        "overall_score": 80,
        "token_cost": "very_low",
        "complexity": "very_low",
        "priority": "CRITICAL",
        "note": "High success rate, near-zero token overhead. Essential for Phase 10 completion."
      }
    },
    {
      "id": "strat-004-code-generation-syntax-validation",
      "name": "Code Generation Syntax Validation Strategy",
      "description": "Systematic approach to prevent syntax errors in generated code during Phases 6 and 10",
      "pattern": {
        "problem": "Template literals, strings, and other syntax can be incorrectly escaped or formatted during code generation",
        "example_error": "Escaped backticks (\\`) in template literals cause SyntaxError: Invalid or unexpected token",
        "root_cause": "String manipulation in code generators without proper escaping awareness"
      },
      "phases": {
        "phase_6_implementation": {
          "name": "Code Generation",
          "critical_checks": [
            "Template literals MUST use plain backticks (`), never escaped (\\`)",
            "Validate all generated template strings before output",
            "Use AST parsing to detect syntax errors before writing files",
            "Quote all variable interpolations: ${variable} (not \\${variable})"
          ]
        },
        "phase_10_deployment": {
          "name": "Artifact Generation",
          "critical_checks": [
            "All generated files must pass Node.js syntax check: node -c",
            "Docker-related files should validate Dockerfile syntax",
            "JSON files should validate with JSON.parse()",
            "Shell scripts should validate with bash -n"
          ]
        }
      },
      "validation_techniques": [
        "Pre-execution syntax validation: `node -c file.js`",
        "AST parsing: Use acorn or esprima to parse generated code",
        "Unit tests on code generation functions",
        "Generate-and-test cycle: create files, validate, report errors"
      ],
      "implementation": {
        "timing": "After code generation, before file writing",
        "error_handling": "Collect all syntax errors, report with line numbers and suggestions",
        "recovery": "Log detailed error context for Knowledge Base learning"
      },
      "success_indicators": [
        "All generated files pass syntax validation before use",
        "Zero SyntaxError exceptions during workflow execution",
        "Template literal errors reduced to 0%"
      ],
      "tools_and_libs": [
        "acorn (JavaScript AST parsing)",
        "yaml (for YAML validation)",
        "JSON.parse (for JSON validation)",
        "child_process.execSync (for node -c)"
      ],
      "success_rate": 0.98,
      "tags": ["code-generation", "syntax-validation", "quality-assurance", "phase-6", "phase-10"],
      "quality_metrics": {
        "workflow_completeness": 100,
        "code_efficiency": 90,
        "feature_completeness": 0,
        "test_quality": 85,
        "resource_efficiency": 80,
        "overall_score": 91,
        "token_cost": "low",
        "complexity": "low",
        "priority": "CRITICAL",
        "note": "Prevents entire workflow failure from simple syntax mistakes. Early detection saves debugging time."
      }
    },
    {
      "id": "strat-004-esm-module-consistency",
      "name": "ESM Module Consistency Strategy",
      "description": "Ensure all generated Node.js code uses consistent module system (ESM or CommonJS) based on package.json configuration",
      "category": "code-generation-standards",
      "priority": "CRITICAL",
      "problem_statement": "Mixing ESM (import/export) and CommonJS (require/module.exports) syntax causes runtime errors",
      "phases": {
        "phase_6_implementation": {
          "name": "Implementation with Module System Check",
          "steps": [
            "1. Read package.json to determine module system (check 'type' field)",
            "2. Set global flag: isESModule = (packageJson.type === 'module')",
            "3. For ALL code generation, use consistent syntax based on flag:",
            "   - If isESModule: use 'import' and 'export default' ONLY",
            "   - If not ESModule: use 'require()' and 'module.exports' ONLY",
            "4. Place all imports at the top of the file (before any code execution)",
            "5. For route/middleware registration: import first, then use in app.use()",
            "6. Handle both default and named exports: 'routes.default || routes'",
            "7. Never use require() in files where package.json has 'type: module'"
          ],
          "validation": [
            "Grep all generated .js files for 'require(' if type: module",
            "Run 'node --check <file>' on all generated JavaScript",
            "Verify server starts with 'npm start'",
            "All tests pass with 'npm test'"
          ]
        },
        "phase_7_review": {
          "name": "Code Review for Module Consistency",
          "checks": [
            "If package.json has 'type: module', flag any require() as CRITICAL error",
            "Verify imports are at top of file",
            "Check for dynamic imports using await import() not require()",
            "Validate module.exports not used in ESM files"
          ]
        }
      },
      "implementation_template": {
        "esm_main_app": {
          "imports": [
            "import express from 'express';",
            "import cors from 'cors';",
            "import 'dotenv/config';",
            "import routes from './routes/index.js';"
          ],
          "usage": "app.use('/api', routes.default || routes);",
          "exports": "export default app;"
        },
        "esm_router": {
          "imports": [
            "import express from 'express';",
            "import route1 from './api-1.js';",
            "import route2 from './api-2.js';"
          ],
          "usage": [
            "const router = express.Router();",
            "router.use('/path1', route1);",
            "router.use('/path2', route2);"
          ],
          "exports": "export default router;"
        },
        "commonjs_main_app": {
          "requires": [
            "const express = require('express');",
            "const cors = require('cors');",
            "require('dotenv').config();",
            "const routes = require('./routes');"
          ],
          "usage": "app.use('/api', routes);",
          "exports": "module.exports = app;"
        }
      },
      "error_patterns_to_avoid": [
        {
          "pattern": "require() in ESM context",
          "error": "ReferenceError: require is not defined in ES module scope",
          "fix": "Replace with: import statement at top of file"
        },
        {
          "pattern": "module.exports in ESM",
          "error": "ReferenceError: module is not defined in ES module scope",
          "fix": "Replace with: export default"
        },
        {
          "pattern": "import in CommonJS without flag",
          "error": "SyntaxError: Cannot use import statement outside a module",
          "fix": "Add 'type: module' to package.json OR use require()"
        }
      ],
      "detection_methods": [
        "Static analysis: grep for 'require\\(' in .js files",
        "AST parsing: detect CommonJS nodes in ESM packages",
        "Runtime check: node --check <file>",
        "Integration test: npm start with timeout"
      ],
      "rollout": {
        "immediate_actions": [
          "Update ImplementationAgent templates to check packageJson.type",
          "Add module system flag to code generation context",
          "Update all template strings to use consistent syntax"
        ],
        "validation_harness": [
          "Add npm start timeout test to IncrementalWorkflow validation",
          "Grep check for require() when type: module detected",
          "Fail validation if module inconsistency found"
        ]
      },
      "success_metrics": {
        "zero_module_errors": "No ReferenceError or SyntaxError related to module system",
        "server_startup_rate": "100% successful npm start",
        "test_pass_rate": "100% npm test success",
        "validation_detection": "Catch module inconsistencies before human review"
      },
      "tools_and_libs": [
        "grep for pattern detection",
        "node --check for syntax validation",
        "package.json parser to read 'type' field",
        "AST tools (optional): acorn, esprima"
      ],
      "success_rate": 1.0,
      "tags": ["esm", "commonjs", "modules", "import", "require", "code-generation", "phase-6", "phase-7"],
      "quality_metrics": {
        "workflow_completeness": 100,
        "code_efficiency": 100,
        "feature_completeness": 0,
        "test_quality": 100,
        "resource_efficiency": 100,
        "overall_score": 100,
        "token_cost": "very_low",
        "complexity": "low",
        "priority": "CRITICAL",
        "note": "Simple flag-based check prevents runtime errors. Zero tolerance for module system mixing. Detection is trivial (grep), fix is straightforward (template change)."
      }
    }
  ]
}
